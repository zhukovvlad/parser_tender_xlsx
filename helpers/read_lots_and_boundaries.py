"""
Модуль для извлечения информации о лотах из листа Excel.

Этот модуль содержит функцию, которая идентифицирует строки, объявляющие
начало нового лота (по ключевой фразе в определенной колонке), и для каждого
найденного лота собирает его название. Важной особенностью является то,
как он агрегирует предложения подрядчиков для каждого лота.
"""

from typing import Dict, Any
from openpyxl.worksheet.worksheet import Worksheet

# Импорт констант, используемых для ключей JSON и для поиска лотов
from constants import (
    JSON_KEY_LOT_INDEX,
    JSON_KEY_LOT_TITLE,
    JSON_KEY_PROPOSALS,
    PARSE_TABLE_LOT_NUMBER,  # Ожидаемый текстовый маркер для начала лота, например, "лот №"
    START_INDEXING_LOT_ROW   # Номер строки, с которой начинается поиск лотов
)
# Локальный импорт функции для получения предложений подрядчиков
from .get_proposals import get_proposals


def read_lots_and_boundaries(ws: Worksheet) -> Dict[str, Dict[str, Any]]:
    """
    Извлекает информацию обо всех лотах, найденных на листе Excel.

    Функция сканирует лист, начиная со строки, указанной в константе
    `START_INDEXING_LOT_ROW` (например, 10-я строка), и до конца листа.
    В каждой строке проверяется значение в 4-й колонке (колонка 'D').
    Если значение в этой ячейке является строкой и (после удаления пробелов
    и приведения к нижнему регистру) начинается с текста константы
    `PARSE_TABLE_LOT_NUMBER` (например, "лот №", также в нижнем регистре),
    то эта строка считается началом нового лота.

    Для каждого найденного лота:
    -   В качестве названия лота (`JSON_KEY_LOT_TITLE`) сохраняется полное
        содержимое ячейки 'D' (очищенное от крайних пробелов).
    -   Вызывается функция `get_proposals(ws)` для получения предложений
        подрядчиков. Эти предложения сохраняются под ключом `JSON_KEY_PROPOSALS`.

    !!! ВАЖНОЕ ЗАМЕЧАНИЕ ПО ЛОГИКЕ РАБОТЫ `get_proposals` !!!
        Функция `get_proposals(ws)` вызывается с одним и тем же объектом листа `ws`
        для КАЖДОГО идентифицированного лота, без передачи информации о границах
        (начальной и конечной строках) самого лота. Текущая реализация
        `get_proposals` (см. соответствующий модуль) считывает ВСЕХ подрядчиков
        и ВСЕ их предложения со всего листа.
        Следовательно, для каждого лота в результирующем словаре под ключом
        `JSON_KEY_PROPOSALS` будет содержаться ОДИН И ТОТ ЖЕ НАБОР ВСЕХ
        предложений, найденных на листе, а не только тех, что относятся
        к конкретному лоту. Если требуется разделение предложений по лотам,
        необходимо либо модифицировать `get_proposals` для учета границ лота,
        либо выполнять дополнительную фильтрацию на последующих этапах.

    Args:
        ws (Worksheet): Лист Excel (объект openpyxl.worksheet.worksheet.Worksheet),
            с которого считываются данные о лотах.

    Returns:
        Dict[str, Dict[str, Any]]: Словарь, где:
            - Ключи (str): Идентификаторы лотов, сгенерированные с использованием
              `JSON_KEY_LOT_INDEX` и порядкового номера (например, "lot_1", "lot_2").
            - Значения (Dict[str, Any]): Словари, содержащие информацию по каждому лоту:
                - `JSON_KEY_LOT_TITLE` (str): Полное наименование лота.
                - `JSON_KEY_PROPOSALS` (Dict): Словарь с предложениями подрядчиков
                  (вероятно, все предложения со всего листа, см. ВАЖНОЕ ЗАМЕЧАНИЕ выше).
            Если лоты не найдены, возвращается пустой словарь.
    """
    max_sheet_row = ws.max_row
    found_lots_data: Dict[str, Dict[str, Any]] = {}
    lot_counter = 1  # Счетчик для генерации уникальных ключей лотов (lot_1, lot_2, ...)

    # Итерация по строкам, начиная с START_INDEXING_LOT_ROW и до конца листа
    for current_row_num in range(START_INDEXING_LOT_ROW, max_sheet_row + 1):
        # Получаем значение из 4-й колонки (D) текущей строки
        cell_value_col_d = ws.cell(row=current_row_num, column=4).value

        # Проверяем, является ли значение строкой и начинается ли оно
        # с маркера лота (например, "лот №"), регистронезависимо.
        if isinstance(cell_value_col_d, str) and \
           cell_value_col_d.strip().lower().startswith(PARSE_TABLE_LOT_NUMBER.lower()):
            
            # Обнаружено начало нового лота
            lot_key = f"{JSON_KEY_LOT_INDEX}{lot_counter}"
            
            # Сохраняем информацию о лоте.
            # Обратите внимание на вызов get_proposals(ws) - см. ВАЖНОЕ ЗАМЕЧАНИЕ в докстринге.
            found_lots_data[lot_key] = {
                JSON_KEY_LOT_TITLE: cell_value_col_d.strip(),
                JSON_KEY_PROPOSALS: get_proposals(ws) 
            }
            lot_counter += 1 # Увеличиваем счетчик для следующего лота
                
    return found_lots_data