def read_executer_block(ws):
    """
    Извлекает информацию об исполнителе (имя, телефон, дата составления)
    из блока данных, расположенного в нижней части листа Excel.

    Функция сканирует три конкретные строки перед последними двумя строками листа
    (а именно, строки: `max_row - 5`, `max_row - 4`, `max_row - 3`).
    В каждой из этих строк она проверяет значение во второй колонке (колонке B)
    на наличие ключевых фраз:
    - "исполнитель": для извлечения имени исполнителя.
    - "тел": для извлечения номера телефона.
    - "дата составления": для извлечения даты.

    Предполагается, что искомые данные следуют за этими ключевыми фразами.
    Для "исполнитель" и "тел" данные извлекаются после первого двоеточия.
    Для "дата составления" данные извлекаются после самой этой фразы.
    Поиск ключевых фраз производится без учета регистра.

    Args:
        ws (openpyxl.worksheet.worksheet.Worksheet): Лист Excel (объект openpyxl),
            из которого считываются данные.

    Returns:
        dict: Словарь с тремя ключами: "name", "phone", "date".
              Значениями являются извлеченные строки данных или `None`,
              если соответствующая информация не была найдена.
              Пример:
              {
                  "name": "Иванов И.И.",
                  "phone": "+7 (123) 456-78-90",
                  "date": "16.05.2025"
              }

    Примечания по реализации:
    - Если значение в проверяемой ячейке не является строкой (например, число или None),
      при вызове метода `.lower()` или `.split()` возникнет ошибка `AttributeError`.
      Рекомендуется добавить проверку `isinstance(cell_value, str)`.
    - Если строка начинается, например, с "исполнитель", но не содержит двоеточия,
      вызов `.split(":", 1)[1]` приведет к ошибке `IndexError`.
    - Извлечение значений для "name" и "phone" происходит из оригинальной строки
      `cell_value` после проверки префикса в нижнем регистре. Извлечение "date"
      происходит из строки `cell_value`, приведенной к нижнему регистру.
    """
    last_row = ws.max_row
    # Инициализируем словарь для хранения найденных значений
    last_three = {"name": None, "phone": None, "date": None}
    
    # Определяем диапазон строк для сканирования:
    # ws.max_row - 5, ws.max_row - 4, ws.max_row - 3
    # Например, если max_row = 20, то сканируются строки 15, 16, 17.
    # range(last_row - 5, last_row - 2) даст именно эти индексы.
    for i in range(last_row - 5, last_row - 2):
        if i < 1: # Добавлена проверка, чтобы не уйти в отрицательные или нулевые строки, если лист очень короткий
            continue

        cell_value = ws.cell(row=i, column=2).value # Значение из второй колонки (B)

        # Проверяем, является ли значение ячейки строкой, перед вызовом строковых методов
        if isinstance(cell_value, str):
            # Проверка на "исполнитель"
            if cell_value.lower().startswith("исполнитель"):
                try:
                    last_three["name"] = cell_value.split(":", 1)[1].strip()
                except IndexError:
                    # Если двоеточие отсутствует, оставляем None или записываем всю строку
                    # В данном случае, лучше оставить None или обработать иначе, если нужно
                    pass # last_three["name"] останется None или предыдущим значением
            # Проверка на "тел"
            elif cell_value.lower().startswith("тел"):
                try:
                    last_three["phone"] = cell_value.split(":", 1)[1].strip()
                except IndexError:
                    pass # last_three["phone"] останется None
            # Проверка на "дата составления"
            elif cell_value.lower().startswith("дата составления"):
                # Значение для даты извлекается из строки, приведенной к нижнему регистру
                try:
                    last_three["date"] = cell_value.lower().split("дата составления", 1)[1].strip()
                except IndexError:
                    # Это условие маловероятно, если startswith сработал, 
                    # но для единообразия можно оставить try-except
                    pass # last_three["date"] останется None
                    
    return last_three