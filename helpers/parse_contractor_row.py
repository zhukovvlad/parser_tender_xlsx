def parse_contractor_row(ws, row_index, contractor):
    """
    Извлекает значения, относящиеся к подрядчику, из одной строки листа Excel
    и возвращает их в виде словаря, поддерживающего вложенную структуру.

    На основе информации о начальной колонке подрядчика и количестве занимаемых им
    колонок (`colspan`), функция определяет набор ожидаемых полей данных.
    Значения извлекаются из ячеек соответствующего диапазона в указанной строке
    и сопоставляются с этими полями, создавая вложенный словарь, если это
    определено структурой ключей (через точку).

    Args:
        ws (openpyxl.worksheet.worksheet.Worksheet): Рабочий лист openpyxl,
            из которого считываются данные.
        row_index (int): Номер строки (1-индексация), из которой извлекаются значения.
        contractor (dict): Словарь с метаданными подрядчика. Должен содержать:
            - "column_start" (int): Номер начальной колонки данных для этого подрядчика.
            - "merged_shape" (dict): Словарь, содержащий информацию об объединении
              ячеек подрядчика, в частности ключ "colspan" (int), указывающий
              количество колонок, занимаемых данными подрядчика.

    Returns:
        dict: Словарь с данными подрядчика для указанной строки. Ключи словаря
              соответствуют полям данных (например, "предлагаемое количество",
              "комментарий участника"). Некоторые ключи могут быть вложенными,
              например, ключ "стоимость за единицу.материалы" приведет к структуре:
              `{"стоимость за единицу": {"материалы": <значение>}}`.
              Значениями являются данные из соответствующих ячеек листа.

    Raises:
        ValueError: Если значение `contractor["merged_shape"]["colspan"]`
                    не поддерживается (не равно 8, 9, 10, 11 или 12),
                    исключение будет возбуждено из вложенной функции
                    `get_column_keys`.
    """

    def get_column_keys(colspan):
        """
        Возвращает список строковых ключей для полей данных подрядчика
        в зависимости от ширины блока (`colspan`), занимаемого подрядчиком.

        Ключи могут быть составными (разделенными точкой), что указывает
        на необходимость создания вложенной структуры в результирующем словаре.
        Поддерживаемые значения `colspan`: 12, 11, 10, 9, 8.

        Args:
            colspan (int): Количество колонок, занимаемых данными подрядчика.

        Returns:
            list[str]: Список ключей, порядок которых соответствует ожидаемому
                       расположению данных подрядчика в строке.

        Raises:
            ValueError: Если переданное значение `colspan` не поддерживается.
        """
        if colspan == 12:
            # ... (полный список ключей как в исходном коде)
            return [
                "предлагаемое количество",
                "стоимость за единицу.материалы",
                "стоимость за единицу.работы",
                "стоимость за единицу.косвенные расходы",
                "стоимость за единицу.всего",
                "стоимость всего.материалы",
                "стоимость всего.работы",
                "стоимость всего.косвенные расходы",
                "стоимость всего.всего",
                "стоимость всего за объемы заказчика",
                "комментарий участника",
                "отклонение от расчетной стоимости"
            ]
        elif colspan == 11:
            # ... (полный список ключей)
            return [
                "предлагаемое количество",
                "стоимость за единицу.материалы",
                "стоимость за единицу.работы",
                "стоимость за единицу.косвенные расходы",
                "стоимость за единицу.всего",
                "стоимость всего.материалы",
                "стоимость всего.работы",
                "стоимость всего.косвенные расходы",
                "стоимость всего.всего",
                "стоимость всего за объемы заказчика",
                "отклонение от расчетной стоимости"
            ]
        elif colspan == 10:
            # ... (полный список ключей)
            return [
                "стоимость за единицу.материалы",
                "стоимость за единицу.работы",
                "стоимость за единицу.косвенные расходы",
                "стоимость за единицу.всего",
                "стоимость всего.материалы",
                "стоимость всего.работы",
                "стоимость всего.косвенные расходы",
                "стоимость всего.всего",
                "комментарий участника",
                "отклонение от расчетной стоимости"
            ]
        elif colspan == 9:
            # ... (полный список ключей)
            return [
                "стоимость за единицу.материалы",
                "стоимость за единицу.работы",
                "стоимость за единицу.косвенные расходы",
                "стоимость за единицу.всего",
                "стоимость всего.материалы",
                "стоимость всего.работы",
                "стоимость всего.косвенные расходы",
                "стоимость всего.всего",
                "отклонение от расчетной стоимости"
            ]
        elif colspan == 8:
            # ... (полный список ключей)
            return [
                "стоимость за единицу.материалы",
                "стоимость за единицу.работы",
                "стоимость за единицу.косвенные расходы",
                "стоимость за единицу.всего",
                "стоимость всего.материалы",
                "стоимость всего.работы",
                "стоимость всего.косвенные расходы",
                "стоимость всего.всего"
            ]
        else:
            raise ValueError(f"Неизвестный colspan подрядчика: {colspan}")

    def map_to_nested_dict(cells, keys):
        """
        Сопоставляет список значений ячеек (`cells`) со списком ключей (`keys`)
        и создает вложенный словарь.

        Если ключ в списке `keys` содержит точку (например, "a.b.c"),
        создается соответствующая вложенная структура словарей.

        Args:
            cells (list[openpyxl.cell.cell.Cell]): Список объектов ячеек,
                значения которых будут использоваться.
            keys (list[str]): Список строковых ключей, соответствующий ячейкам.

        Returns:
            dict: Вложенный словарь, где значения из `cells` сопоставлены
                  ключам из `keys`.
        """
        result = {}
        for key, cell in zip(keys, cells): # Итерируемся одновременно по ключам и ячейкам
            parts = key.split(".") # Разделяем составной ключ на части
            current = result
            # Проходим по частям ключа, создавая вложенные словари при необходимости
            for part in parts[:-1]:
                current = current.setdefault(part, {}) # setdefault создает ключ, если его нет
            current[parts[-1]] = cell.value # Присваиваем значение последней части ключа
        return result

    # ----- Основная логика parse_contractor_row -----
    column_start = contractor["column_start"]
    colspan = contractor["merged_shape"]["colspan"]
    
    # Получаем список ключей, соответствующий colspan подрядчика
    keys = get_column_keys(colspan)

    # Извлекаем ячейки подрядчика из указанной строки
    # (от column_start до column_start + colspan - 1)
    cells_to_parse = [
        ws.cell(row=row_index, column=col)
        for col in range(column_start, column_start + colspan)
    ]

    # Создаем вложенный словарь из ячеек и ключей
    return map_to_nested_dict(cells_to_parse, keys)